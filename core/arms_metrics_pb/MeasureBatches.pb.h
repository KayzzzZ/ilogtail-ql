// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MeasureBatches.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MeasureBatches_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MeasureBatches_2eproto

#include <google/protobuf/port_def.inc>
#include <limits>
#include <string>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/map.h> // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/message.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>

#include <google/protobuf/port_undef.inc>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MeasureBatches_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace arms_metrics {
class AnyMetadata;
} // namespace arms_metrics
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MeasureBatches_2eproto {
    static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MeasureBatches_2eproto;
namespace arms_metrics {
class Measure;
struct MeasureDefaultTypeInternal;
extern MeasureDefaultTypeInternal _Measure_default_instance_;
class MeasureBatch;
struct MeasureBatchDefaultTypeInternal;
extern MeasureBatchDefaultTypeInternal _MeasureBatch_default_instance_;
class MeasureBatch_CommonTagsEntry_DoNotUse;
struct MeasureBatch_CommonTagsEntry_DoNotUseDefaultTypeInternal;
extern MeasureBatch_CommonTagsEntry_DoNotUseDefaultTypeInternal
    _MeasureBatch_CommonTagsEntry_DoNotUse_default_instance_;
class MeasureBatches;
struct MeasureBatchesDefaultTypeInternal;
extern MeasureBatchesDefaultTypeInternal _MeasureBatches_default_instance_;
class Measures;
struct MeasuresDefaultTypeInternal;
extern MeasuresDefaultTypeInternal _Measures_default_instance_;
class Measures_LabelsEntry_DoNotUse;
struct Measures_LabelsEntry_DoNotUseDefaultTypeInternal;
extern Measures_LabelsEntry_DoNotUseDefaultTypeInternal _Measures_LabelsEntry_DoNotUse_default_instance_;
} // namespace arms_metrics
PROTOBUF_NAMESPACE_OPEN
template <>
::proto::Measure* Arena::CreateMaybeMessage<::proto::Measure>(Arena*);
template <>
::proto::MeasureBatch* Arena::CreateMaybeMessage<::proto::MeasureBatch>(Arena*);
template <>
::proto::MeasureBatch_CommonTagsEntry_DoNotUse*
Arena::CreateMaybeMessage<::proto::MeasureBatch_CommonTagsEntry_DoNotUse>(Arena*);
template <>
::proto::MeasureBatches* Arena::CreateMaybeMessage<::proto::MeasureBatches>(Arena*);
template <>
::proto::Measures* Arena::CreateMaybeMessage<::proto::Measures>(Arena*);
template <>
::proto::Measures_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::proto::Measures_LabelsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace arms_metrics {

enum EnumUnit : int {
    UNKNOWN = 0,
    COUNT = 1,
    RATIO = 2,
    PERCENT = 3,
    BYTE = 4,
    SECOND = 5,
    MILLISECONDS = 6,
    EnumUnit_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    EnumUnit_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EnumUnit_IsValid(int value);
constexpr EnumUnit EnumUnit_MIN = UNKNOWN;
constexpr EnumUnit EnumUnit_MAX = MILLISECONDS;
constexpr int EnumUnit_ARRAYSIZE = EnumUnit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EnumUnit_descriptor();
template <typename T>
inline const std::string& EnumUnit_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EnumUnit>::value || ::std::is_integral<T>::value,
                  "Incorrect type passed to function EnumUnit_Name.");
    return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(EnumUnit_descriptor(), enum_t_value);
}
inline bool EnumUnit_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EnumUnit* value) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EnumUnit>(EnumUnit_descriptor(), name, value);
}
// ===================================================================

class MeasureBatches final
    : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.MeasureBatches) */ {
public:
    inline MeasureBatches() : MeasureBatches(nullptr) {}
    ~MeasureBatches() override;
    explicit PROTOBUF_CONSTEXPR MeasureBatches(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    MeasureBatches(const MeasureBatches& from);
    MeasureBatches(MeasureBatches&& from) noexcept : MeasureBatches() { *this = ::std::move(from); }

    inline MeasureBatches& operator=(const MeasureBatches& from) {
        CopyFrom(from);
        return *this;
    }
    inline MeasureBatches& operator=(MeasureBatches&& from) noexcept {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
        return default_instance().GetMetadata().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
        return default_instance().GetMetadata().reflection;
    }
    static const MeasureBatches& default_instance() { return *internal_default_instance(); }
    static inline const MeasureBatches* internal_default_instance() {
        return reinterpret_cast<const MeasureBatches*>(&_MeasureBatches_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(MeasureBatches& a, MeasureBatches& b) { a.Swap(&b); }
    inline void Swap(MeasureBatches* other) {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(MeasureBatches* other) {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    MeasureBatches* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
        return CreateMaybeMessage<MeasureBatches>(arena);
    }
    using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
    void CopyFrom(const MeasureBatches& from);
    using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
    void MergeFrom(const MeasureBatches& from) { MeasureBatches::MergeImpl(*this, from); }

private:
    static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

public:
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(MeasureBatches* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() { return "proto.MeasureBatches"; }

protected:
    explicit MeasureBatches(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    static const ClassData _class_data_;
    const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kMeasureBatchesFieldNumber = 1,
    };
    // repeated .proto.MeasureBatch measureBatches = 1;
    int measurebatches_size() const;

private:
    int _internal_measurebatches_size() const;

public:
    void clear_measurebatches();
    ::proto::MeasureBatch* mutable_measurebatches(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::MeasureBatch>* mutable_measurebatches();

private:
    const ::proto::MeasureBatch& _internal_measurebatches(int index) const;
    ::proto::MeasureBatch* _internal_add_measurebatches();

public:
    const ::proto::MeasureBatch& measurebatches(int index) const;
    ::proto::MeasureBatch* add_measurebatches();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::MeasureBatch>& measurebatches() const;

    // @@protoc_insertion_point(class_scope:proto.MeasureBatches)
private:
    class _Internal;

    template <typename T>
    friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::MeasureBatch> measurebatches_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_MeasureBatches_2eproto;
};
// -------------------------------------------------------------------

class MeasureBatch_CommonTagsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<
                                                  MeasureBatch_CommonTagsEntry_DoNotUse,
                                                  std::string,
                                                  std::string,
                                                  ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
                                                  ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
    typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MeasureBatch_CommonTagsEntry_DoNotUse,
                                                        std::string,
                                                        std::string,
                                                        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
                                                        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING>
        SuperType;
    MeasureBatch_CommonTagsEntry_DoNotUse();
    explicit PROTOBUF_CONSTEXPR
        MeasureBatch_CommonTagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
    explicit MeasureBatch_CommonTagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
    void MergeFrom(const MeasureBatch_CommonTagsEntry_DoNotUse& other);
    static const MeasureBatch_CommonTagsEntry_DoNotUse* internal_default_instance() {
        return reinterpret_cast<const MeasureBatch_CommonTagsEntry_DoNotUse*>(
            &_MeasureBatch_CommonTagsEntry_DoNotUse_default_instance_);
    }
    static bool ValidateKey(std::string* s) {
        return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
            s->data(),
            static_cast<int>(s->size()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE,
            "proto.MeasureBatch.CommonTagsEntry.key");
    }
    static bool ValidateValue(std::string* s) {
        return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
            s->data(),
            static_cast<int>(s->size()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE,
            "proto.MeasureBatch.CommonTagsEntry.value");
    }
    using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
    friend struct ::TableStruct_MeasureBatches_2eproto;
};

// -------------------------------------------------------------------

class MeasureBatch final
    : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.MeasureBatch) */ {
public:
    inline MeasureBatch() : MeasureBatch(nullptr) {}
    ~MeasureBatch() override;
    explicit PROTOBUF_CONSTEXPR MeasureBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    MeasureBatch(const MeasureBatch& from);
    MeasureBatch(MeasureBatch&& from) noexcept : MeasureBatch() { *this = ::std::move(from); }

    inline MeasureBatch& operator=(const MeasureBatch& from) {
        CopyFrom(from);
        return *this;
    }
    inline MeasureBatch& operator=(MeasureBatch&& from) noexcept {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
        return default_instance().GetMetadata().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
        return default_instance().GetMetadata().reflection;
    }
    static const MeasureBatch& default_instance() { return *internal_default_instance(); }
    static inline const MeasureBatch* internal_default_instance() {
        return reinterpret_cast<const MeasureBatch*>(&_MeasureBatch_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(MeasureBatch& a, MeasureBatch& b) { a.Swap(&b); }
    inline void Swap(MeasureBatch* other) {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(MeasureBatch* other) {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    MeasureBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
        return CreateMaybeMessage<MeasureBatch>(arena);
    }
    using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
    void CopyFrom(const MeasureBatch& from);
    using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
    void MergeFrom(const MeasureBatch& from) { MeasureBatch::MergeImpl(*this, from); }

private:
    static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

public:
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(MeasureBatch* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() { return "proto.MeasureBatch"; }

protected:
    explicit MeasureBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

private:
    static void ArenaDtor(void* object);

public:
    static const ClassData _class_data_;
    const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------


    // accessors -------------------------------------------------------

    enum : int {
        kCommonTagsFieldNumber = 6,
        kMeasuresFieldNumber = 7,
        kVersionFieldNumber = 1,
        kTypeFieldNumber = 2,
        kPidFieldNumber = 4,
        kIpFieldNumber = 5,
        kTimeFieldNumber = 3,
    };
    // map<string, string> commonTags = 6;
    int commontags_size() const;

private:
    int _internal_commontags_size() const;

public:
    void clear_commontags();

private:
    const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>& _internal_commontags() const;
    ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>* _internal_mutable_commontags();

public:
    const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>& commontags() const;
    ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>* mutable_commontags();

    // repeated .proto.Measures measures = 7;
    int measures_size() const;

private:
    int _internal_measures_size() const;

public:
    void clear_measures();
    ::proto::Measures* mutable_measures(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::Measures>* mutable_measures();

private:
    const ::proto::Measures& _internal_measures(int index) const;
    ::proto::Measures* _internal_add_measures();

public:
    const ::proto::Measures& measures(int index) const;
    ::proto::Measures* add_measures();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::Measures>& measures() const;

    // string version = 1;
    void clear_version();
    const std::string& version() const;
    template <typename ArgT0 = const std::string&, typename... ArgT>
    void set_version(ArgT0&& arg0, ArgT... args);
    std::string* mutable_version();
    PROTOBUF_NODISCARD std::string* release_version();
    void set_allocated_version(std::string* version);

private:
    const std::string& _internal_version() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
    std::string* _internal_mutable_version();

public:
    // string type = 2;
    void clear_type();
    const std::string& type() const;
    template <typename ArgT0 = const std::string&, typename... ArgT>
    void set_type(ArgT0&& arg0, ArgT... args);
    std::string* mutable_type();
    PROTOBUF_NODISCARD std::string* release_type();
    void set_allocated_type(std::string* type);

private:
    const std::string& _internal_type() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
    std::string* _internal_mutable_type();

public:
    // string pid = 4;
    void clear_pid();
    const std::string& pid() const;
    template <typename ArgT0 = const std::string&, typename... ArgT>
    void set_pid(ArgT0&& arg0, ArgT... args);
    std::string* mutable_pid();
    PROTOBUF_NODISCARD std::string* release_pid();
    void set_allocated_pid(std::string* pid);

private:
    const std::string& _internal_pid() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_pid(const std::string& value);
    std::string* _internal_mutable_pid();

public:
    // string ip = 5;
    void clear_ip();
    const std::string& ip() const;
    template <typename ArgT0 = const std::string&, typename... ArgT>
    void set_ip(ArgT0&& arg0, ArgT... args);
    std::string* mutable_ip();
    PROTOBUF_NODISCARD std::string* release_ip();
    void set_allocated_ip(std::string* ip);

private:
    const std::string& _internal_ip() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
    std::string* _internal_mutable_ip();

public:
    // int64 time = 3;
    void clear_time();
    int64_t time() const;
    void set_time(int64_t value);

private:
    int64_t _internal_time() const;
    void _internal_set_time(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:proto.MeasureBatch)
private:
    class _Internal;

    template <typename T>
    friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::MapField<MeasureBatch_CommonTagsEntry_DoNotUse,
                                                    std::string,
                                                    std::string,
                                                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
                                                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING>
            commontags_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::Measures> measures_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
        int64_t time_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_MeasureBatches_2eproto;
};
// -------------------------------------------------------------------

class Measures_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<
                                          Measures_LabelsEntry_DoNotUse,
                                          std::string,
                                          std::string,
                                          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
                                          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
    typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Measures_LabelsEntry_DoNotUse,
                                                        std::string,
                                                        std::string,
                                                        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
                                                        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING>
        SuperType;
    Measures_LabelsEntry_DoNotUse();
    explicit PROTOBUF_CONSTEXPR Measures_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
    explicit Measures_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
    void MergeFrom(const Measures_LabelsEntry_DoNotUse& other);
    static const Measures_LabelsEntry_DoNotUse* internal_default_instance() {
        return reinterpret_cast<const Measures_LabelsEntry_DoNotUse*>(
            &_Measures_LabelsEntry_DoNotUse_default_instance_);
    }
    static bool ValidateKey(std::string* s) {
        return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
            s->data(),
            static_cast<int>(s->size()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE,
            "proto.Measures.LabelsEntry.key");
    }
    static bool ValidateValue(std::string* s) {
        return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
            s->data(),
            static_cast<int>(s->size()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE,
            "proto.Measures.LabelsEntry.value");
    }
    using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
    friend struct ::TableStruct_MeasureBatches_2eproto;
};

// -------------------------------------------------------------------

class Measures final
    : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Measures) */ {
public:
    inline Measures() : Measures(nullptr) {}
    ~Measures() override;
    explicit PROTOBUF_CONSTEXPR Measures(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Measures(const Measures& from);
    Measures(Measures&& from) noexcept : Measures() { *this = ::std::move(from); }

    inline Measures& operator=(const Measures& from) {
        CopyFrom(from);
        return *this;
    }
    inline Measures& operator=(Measures&& from) noexcept {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
        return default_instance().GetMetadata().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
        return default_instance().GetMetadata().reflection;
    }
    static const Measures& default_instance() { return *internal_default_instance(); }
    static inline const Measures* internal_default_instance() {
        return reinterpret_cast<const Measures*>(&_Measures_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(Measures& a, Measures& b) { a.Swap(&b); }
    inline void Swap(Measures* other) {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Measures* other) {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Measures* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
        return CreateMaybeMessage<Measures>(arena);
    }
    using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
    void CopyFrom(const Measures& from);
    using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
    void MergeFrom(const Measures& from) { Measures::MergeImpl(*this, from); }

private:
    static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

public:
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Measures* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() { return "proto.Measures"; }

protected:
    explicit Measures(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

private:
    static void ArenaDtor(void* object);

public:
    static const ClassData _class_data_;
    const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------


    // accessors -------------------------------------------------------

    enum : int {
        kLabelsFieldNumber = 1,
        kMeasuresFieldNumber = 2,
    };
    // map<string, string> labels = 1;
    int labels_size() const;

private:
    int _internal_labels_size() const;

public:
    void clear_labels();

private:
    const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>& _internal_labels() const;
    ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>* _internal_mutable_labels();

public:
    const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>& labels() const;
    ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>* mutable_labels();

    // repeated .proto.Measure measures = 2;
    int measures_size() const;

private:
    int _internal_measures_size() const;

public:
    void clear_measures();
    ::proto::Measure* mutable_measures(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::Measure>* mutable_measures();

private:
    const ::proto::Measure& _internal_measures(int index) const;
    ::proto::Measure* _internal_add_measures();

public:
    const ::proto::Measure& measures(int index) const;
    ::proto::Measure* add_measures();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::Measure>& measures() const;

    // @@protoc_insertion_point(class_scope:proto.Measures)
private:
    class _Internal;

    template <typename T>
    friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::MapField<Measures_LabelsEntry_DoNotUse,
                                                    std::string,
                                                    std::string,
                                                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
                                                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING>
            labels_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::Measure> measures_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_MeasureBatches_2eproto;
};
// -------------------------------------------------------------------

class Measure final
    : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Measure) */ {
public:
    inline Measure() : Measure(nullptr) {}
    ~Measure() override;
    explicit PROTOBUF_CONSTEXPR Measure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Measure(const Measure& from);
    Measure(Measure&& from) noexcept : Measure() { *this = ::std::move(from); }

    inline Measure& operator=(const Measure& from) {
        CopyFrom(from);
        return *this;
    }
    inline Measure& operator=(Measure&& from) noexcept {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
        return default_instance().GetMetadata().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
        return default_instance().GetMetadata().reflection;
    }
    static const Measure& default_instance() { return *internal_default_instance(); }
    static inline const Measure* internal_default_instance() {
        return reinterpret_cast<const Measure*>(&_Measure_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(Measure& a, Measure& b) { a.Swap(&b); }
    inline void Swap(Measure* other) {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Measure* other) {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Measure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
        return CreateMaybeMessage<Measure>(arena);
    }
    using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
    void CopyFrom(const Measure& from);
    using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
    void MergeFrom(const Measure& from) { Measure::MergeImpl(*this, from); }

private:
    static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

public:
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Measure* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() { return "proto.Measure"; }

protected:
    explicit Measure(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    static const ClassData _class_data_;
    const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kValueTypeFieldNumber = 1,
        kNameFieldNumber = 2,
        kDescFieldNumber = 5,
        kValueFieldNumber = 3,
        kUnitFieldNumber = 4,
    };
    // string valueType = 1;
    void clear_valuetype();
    const std::string& valuetype() const;
    template <typename ArgT0 = const std::string&, typename... ArgT>
    void set_valuetype(ArgT0&& arg0, ArgT... args);
    std::string* mutable_valuetype();
    PROTOBUF_NODISCARD std::string* release_valuetype();
    void set_allocated_valuetype(std::string* valuetype);

private:
    const std::string& _internal_valuetype() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_valuetype(const std::string& value);
    std::string* _internal_mutable_valuetype();

public:
    // string name = 2;
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT>
    void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // string desc = 5;
    void clear_desc();
    const std::string& desc() const;
    template <typename ArgT0 = const std::string&, typename... ArgT>
    void set_desc(ArgT0&& arg0, ArgT... args);
    std::string* mutable_desc();
    PROTOBUF_NODISCARD std::string* release_desc();
    void set_allocated_desc(std::string* desc);

private:
    const std::string& _internal_desc() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
    std::string* _internal_mutable_desc();

public:
    // double value = 3;
    void clear_value();
    double value() const;
    void set_value(double value);

private:
    double _internal_value() const;
    void _internal_set_value(double value);

public:
    // .proto.EnumUnit unit = 4;
    void clear_unit();
    ::proto::EnumUnit unit() const;
    void set_unit(::proto::EnumUnit value);

private:
    ::proto::EnumUnit _internal_unit() const;
    void _internal_set_unit(::proto::EnumUnit value);

public:
    // @@protoc_insertion_point(class_scope:proto.Measure)
private:
    class _Internal;

    template <typename T>
    friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr valuetype_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
        double value_;
        int unit_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_MeasureBatches_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// MeasureBatches

// repeated .proto.MeasureBatch measureBatches = 1;
inline int MeasureBatches::_internal_measurebatches_size() const {
    return _impl_.measurebatches_.size();
}
inline int MeasureBatches::measurebatches_size() const {
    return _internal_measurebatches_size();
}
inline void MeasureBatches::clear_measurebatches() {
    _impl_.measurebatches_.Clear();
}
inline ::proto::MeasureBatch* MeasureBatches::mutable_measurebatches(int index) {
    // @@protoc_insertion_point(field_mutable:proto.MeasureBatches.measureBatches)
    return _impl_.measurebatches_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::MeasureBatch>* MeasureBatches::mutable_measurebatches() {
    // @@protoc_insertion_point(field_mutable_list:proto.MeasureBatches.measureBatches)
    return &_impl_.measurebatches_;
}
inline const ::proto::MeasureBatch& MeasureBatches::_internal_measurebatches(int index) const {
    return _impl_.measurebatches_.Get(index);
}
inline const ::proto::MeasureBatch& MeasureBatches::measurebatches(int index) const {
    // @@protoc_insertion_point(field_get:proto.MeasureBatches.measureBatches)
    return _internal_measurebatches(index);
}
inline ::proto::MeasureBatch* MeasureBatches::_internal_add_measurebatches() {
    return _impl_.measurebatches_.Add();
}
inline ::proto::MeasureBatch* MeasureBatches::add_measurebatches() {
    ::proto::MeasureBatch* _add = _internal_add_measurebatches();
    // @@protoc_insertion_point(field_add:proto.MeasureBatches.measureBatches)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::MeasureBatch>& MeasureBatches::measurebatches() const {
    // @@protoc_insertion_point(field_list:proto.MeasureBatches.measureBatches)
    return _impl_.measurebatches_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MeasureBatch

// string version = 1;
inline void MeasureBatch::clear_version() {
    _impl_.version_.ClearToEmpty();
}
inline const std::string& MeasureBatch::version() const {
    // @@protoc_insertion_point(field_get:proto.MeasureBatch.version)
    return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void MeasureBatch::set_version(ArgT0&& arg0, ArgT... args) {
    _impl_.version_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:proto.MeasureBatch.version)
}
inline std::string* MeasureBatch::mutable_version() {
    std::string* _s = _internal_mutable_version();
    // @@protoc_insertion_point(field_mutable:proto.MeasureBatch.version)
    return _s;
}
inline const std::string& MeasureBatch::_internal_version() const {
    return _impl_.version_.Get();
}
inline void MeasureBatch::_internal_set_version(const std::string& value) {
    _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* MeasureBatch::_internal_mutable_version() {
    return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* MeasureBatch::release_version() {
    // @@protoc_insertion_point(field_release:proto.MeasureBatch.version)
    return _impl_.version_.Release();
}
inline void MeasureBatch::set_allocated_version(std::string* version) {
    if (version != nullptr) {
    } else {
    }
    _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.version_.IsDefault()) {
        _impl_.version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:proto.MeasureBatch.version)
}

// string type = 2;
inline void MeasureBatch::clear_type() {
    _impl_.type_.ClearToEmpty();
}
inline const std::string& MeasureBatch::type() const {
    // @@protoc_insertion_point(field_get:proto.MeasureBatch.type)
    return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void MeasureBatch::set_type(ArgT0&& arg0, ArgT... args) {
    _impl_.type_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:proto.MeasureBatch.type)
}
inline std::string* MeasureBatch::mutable_type() {
    std::string* _s = _internal_mutable_type();
    // @@protoc_insertion_point(field_mutable:proto.MeasureBatch.type)
    return _s;
}
inline const std::string& MeasureBatch::_internal_type() const {
    return _impl_.type_.Get();
}
inline void MeasureBatch::_internal_set_type(const std::string& value) {
    _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* MeasureBatch::_internal_mutable_type() {
    return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* MeasureBatch::release_type() {
    // @@protoc_insertion_point(field_release:proto.MeasureBatch.type)
    return _impl_.type_.Release();
}
inline void MeasureBatch::set_allocated_type(std::string* type) {
    if (type != nullptr) {
    } else {
    }
    _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.type_.IsDefault()) {
        _impl_.type_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:proto.MeasureBatch.type)
}

// int64 time = 3;
inline void MeasureBatch::clear_time() {
    _impl_.time_ = int64_t{0};
}
inline int64_t MeasureBatch::_internal_time() const {
    return _impl_.time_;
}
inline int64_t MeasureBatch::time() const {
    // @@protoc_insertion_point(field_get:proto.MeasureBatch.time)
    return _internal_time();
}
inline void MeasureBatch::_internal_set_time(int64_t value) {
    _impl_.time_ = value;
}
inline void MeasureBatch::set_time(int64_t value) {
    _internal_set_time(value);
    // @@protoc_insertion_point(field_set:proto.MeasureBatch.time)
}

// string pid = 4;
inline void MeasureBatch::clear_pid() {
    _impl_.pid_.ClearToEmpty();
}
inline const std::string& MeasureBatch::pid() const {
    // @@protoc_insertion_point(field_get:proto.MeasureBatch.pid)
    return _internal_pid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void MeasureBatch::set_pid(ArgT0&& arg0, ArgT... args) {
    _impl_.pid_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:proto.MeasureBatch.pid)
}
inline std::string* MeasureBatch::mutable_pid() {
    std::string* _s = _internal_mutable_pid();
    // @@protoc_insertion_point(field_mutable:proto.MeasureBatch.pid)
    return _s;
}
inline const std::string& MeasureBatch::_internal_pid() const {
    return _impl_.pid_.Get();
}
inline void MeasureBatch::_internal_set_pid(const std::string& value) {
    _impl_.pid_.Set(value, GetArenaForAllocation());
}
inline std::string* MeasureBatch::_internal_mutable_pid() {
    return _impl_.pid_.Mutable(GetArenaForAllocation());
}
inline std::string* MeasureBatch::release_pid() {
    // @@protoc_insertion_point(field_release:proto.MeasureBatch.pid)
    return _impl_.pid_.Release();
}
inline void MeasureBatch::set_allocated_pid(std::string* pid) {
    if (pid != nullptr) {
    } else {
    }
    _impl_.pid_.SetAllocated(pid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.pid_.IsDefault()) {
        _impl_.pid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:proto.MeasureBatch.pid)
}

// string ip = 5;
inline void MeasureBatch::clear_ip() {
    _impl_.ip_.ClearToEmpty();
}
inline const std::string& MeasureBatch::ip() const {
    // @@protoc_insertion_point(field_get:proto.MeasureBatch.ip)
    return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void MeasureBatch::set_ip(ArgT0&& arg0, ArgT... args) {
    _impl_.ip_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:proto.MeasureBatch.ip)
}
inline std::string* MeasureBatch::mutable_ip() {
    std::string* _s = _internal_mutable_ip();
    // @@protoc_insertion_point(field_mutable:proto.MeasureBatch.ip)
    return _s;
}
inline const std::string& MeasureBatch::_internal_ip() const {
    return _impl_.ip_.Get();
}
inline void MeasureBatch::_internal_set_ip(const std::string& value) {
    _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* MeasureBatch::_internal_mutable_ip() {
    return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* MeasureBatch::release_ip() {
    // @@protoc_insertion_point(field_release:proto.MeasureBatch.ip)
    return _impl_.ip_.Release();
}
inline void MeasureBatch::set_allocated_ip(std::string* ip) {
    if (ip != nullptr) {
    } else {
    }
    _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.ip_.IsDefault()) {
        _impl_.ip_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:proto.MeasureBatch.ip)
}

// map<string, string> commonTags = 6;
inline int MeasureBatch::_internal_commontags_size() const {
    return _impl_.commontags_.size();
}
inline int MeasureBatch::commontags_size() const {
    return _internal_commontags_size();
}
inline void MeasureBatch::clear_commontags() {
    _impl_.commontags_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>& MeasureBatch::_internal_commontags() const {
    return _impl_.commontags_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>& MeasureBatch::commontags() const {
    // @@protoc_insertion_point(field_map:proto.MeasureBatch.commonTags)
    return _internal_commontags();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>* MeasureBatch::_internal_mutable_commontags() {
    return _impl_.commontags_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>* MeasureBatch::mutable_commontags() {
    // @@protoc_insertion_point(field_mutable_map:proto.MeasureBatch.commonTags)
    return _internal_mutable_commontags();
}

// repeated .proto.Measures measures = 7;
inline int MeasureBatch::_internal_measures_size() const {
    return _impl_.measures_.size();
}
inline int MeasureBatch::measures_size() const {
    return _internal_measures_size();
}
inline void MeasureBatch::clear_measures() {
    _impl_.measures_.Clear();
}
inline ::proto::Measures* MeasureBatch::mutable_measures(int index) {
    // @@protoc_insertion_point(field_mutable:proto.MeasureBatch.measures)
    return _impl_.measures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::Measures>* MeasureBatch::mutable_measures() {
    // @@protoc_insertion_point(field_mutable_list:proto.MeasureBatch.measures)
    return &_impl_.measures_;
}
inline const ::proto::Measures& MeasureBatch::_internal_measures(int index) const {
    return _impl_.measures_.Get(index);
}
inline const ::proto::Measures& MeasureBatch::measures(int index) const {
    // @@protoc_insertion_point(field_get:proto.MeasureBatch.measures)
    return _internal_measures(index);
}
inline ::proto::Measures* MeasureBatch::_internal_add_measures() {
    return _impl_.measures_.Add();
}
inline ::proto::Measures* MeasureBatch::add_measures() {
    ::proto::Measures* _add = _internal_add_measures();
    // @@protoc_insertion_point(field_add:proto.MeasureBatch.measures)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::Measures>& MeasureBatch::measures() const {
    // @@protoc_insertion_point(field_list:proto.MeasureBatch.measures)
    return _impl_.measures_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Measures

// map<string, string> labels = 1;
inline int Measures::_internal_labels_size() const {
    return _impl_.labels_.size();
}
inline int Measures::labels_size() const {
    return _internal_labels_size();
}
inline void Measures::clear_labels() {
    _impl_.labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>& Measures::_internal_labels() const {
    return _impl_.labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>& Measures::labels() const {
    // @@protoc_insertion_point(field_map:proto.Measures.labels)
    return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>* Measures::_internal_mutable_labels() {
    return _impl_.labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>* Measures::mutable_labels() {
    // @@protoc_insertion_point(field_mutable_map:proto.Measures.labels)
    return _internal_mutable_labels();
}

// repeated .proto.Measure measures = 2;
inline int Measures::_internal_measures_size() const {
    return _impl_.measures_.size();
}
inline int Measures::measures_size() const {
    return _internal_measures_size();
}
inline void Measures::clear_measures() {
    _impl_.measures_.Clear();
}
inline ::proto::Measure* Measures::mutable_measures(int index) {
    // @@protoc_insertion_point(field_mutable:proto.Measures.measures)
    return _impl_.measures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::Measure>* Measures::mutable_measures() {
    // @@protoc_insertion_point(field_mutable_list:proto.Measures.measures)
    return &_impl_.measures_;
}
inline const ::proto::Measure& Measures::_internal_measures(int index) const {
    return _impl_.measures_.Get(index);
}
inline const ::proto::Measure& Measures::measures(int index) const {
    // @@protoc_insertion_point(field_get:proto.Measures.measures)
    return _internal_measures(index);
}
inline ::proto::Measure* Measures::_internal_add_measures() {
    return _impl_.measures_.Add();
}
inline ::proto::Measure* Measures::add_measures() {
    ::proto::Measure* _add = _internal_add_measures();
    // @@protoc_insertion_point(field_add:proto.Measures.measures)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::Measure>& Measures::measures() const {
    // @@protoc_insertion_point(field_list:proto.Measures.measures)
    return _impl_.measures_;
}

// -------------------------------------------------------------------

// Measure

// string valueType = 1;
inline void Measure::clear_valuetype() {
    _impl_.valuetype_.ClearToEmpty();
}
inline const std::string& Measure::valuetype() const {
    // @@protoc_insertion_point(field_get:proto.Measure.valueType)
    return _internal_valuetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void Measure::set_valuetype(ArgT0&& arg0, ArgT... args) {
    _impl_.valuetype_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:proto.Measure.valueType)
}
inline std::string* Measure::mutable_valuetype() {
    std::string* _s = _internal_mutable_valuetype();
    // @@protoc_insertion_point(field_mutable:proto.Measure.valueType)
    return _s;
}
inline const std::string& Measure::_internal_valuetype() const {
    return _impl_.valuetype_.Get();
}
inline void Measure::_internal_set_valuetype(const std::string& value) {
    _impl_.valuetype_.Set(value, GetArenaForAllocation());
}
inline std::string* Measure::_internal_mutable_valuetype() {
    return _impl_.valuetype_.Mutable(GetArenaForAllocation());
}
inline std::string* Measure::release_valuetype() {
    // @@protoc_insertion_point(field_release:proto.Measure.valueType)
    return _impl_.valuetype_.Release();
}
inline void Measure::set_allocated_valuetype(std::string* valuetype) {
    if (valuetype != nullptr) {
    } else {
    }
    _impl_.valuetype_.SetAllocated(valuetype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.valuetype_.IsDefault()) {
        _impl_.valuetype_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:proto.Measure.valueType)
}

// string name = 2;
inline void Measure::clear_name() {
    _impl_.name_.ClearToEmpty();
}
inline const std::string& Measure::name() const {
    // @@protoc_insertion_point(field_get:proto.Measure.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void Measure::set_name(ArgT0&& arg0, ArgT... args) {
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:proto.Measure.name)
}
inline std::string* Measure::mutable_name() {
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:proto.Measure.name)
    return _s;
}
inline const std::string& Measure::_internal_name() const {
    return _impl_.name_.Get();
}
inline void Measure::_internal_set_name(const std::string& value) {
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Measure::_internal_mutable_name() {
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Measure::release_name() {
    // @@protoc_insertion_point(field_release:proto.Measure.name)
    return _impl_.name_.Release();
}
inline void Measure::set_allocated_name(std::string* name) {
    if (name != nullptr) {
    } else {
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:proto.Measure.name)
}

// double value = 3;
inline void Measure::clear_value() {
    _impl_.value_ = 0;
}
inline double Measure::_internal_value() const {
    return _impl_.value_;
}
inline double Measure::value() const {
    // @@protoc_insertion_point(field_get:proto.Measure.value)
    return _internal_value();
}
inline void Measure::_internal_set_value(double value) {
    _impl_.value_ = value;
}
inline void Measure::set_value(double value) {
    _internal_set_value(value);
    // @@protoc_insertion_point(field_set:proto.Measure.value)
}

// .proto.EnumUnit unit = 4;
inline void Measure::clear_unit() {
    _impl_.unit_ = 0;
}
inline ::proto::EnumUnit Measure::_internal_unit() const {
    return static_cast<::proto::EnumUnit>(_impl_.unit_);
}
inline ::proto::EnumUnit Measure::unit() const {
    // @@protoc_insertion_point(field_get:proto.Measure.unit)
    return _internal_unit();
}
inline void Measure::_internal_set_unit(::proto::EnumUnit value) {
    _impl_.unit_ = value;
}
inline void Measure::set_unit(::proto::EnumUnit value) {
    _internal_set_unit(value);
    // @@protoc_insertion_point(field_set:proto.Measure.unit)
}

// string desc = 5;
inline void Measure::clear_desc() {
    _impl_.desc_.ClearToEmpty();
}
inline const std::string& Measure::desc() const {
    // @@protoc_insertion_point(field_get:proto.Measure.desc)
    return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void Measure::set_desc(ArgT0&& arg0, ArgT... args) {
    _impl_.desc_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:proto.Measure.desc)
}
inline std::string* Measure::mutable_desc() {
    std::string* _s = _internal_mutable_desc();
    // @@protoc_insertion_point(field_mutable:proto.Measure.desc)
    return _s;
}
inline const std::string& Measure::_internal_desc() const {
    return _impl_.desc_.Get();
}
inline void Measure::_internal_set_desc(const std::string& value) {
    _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* Measure::_internal_mutable_desc() {
    return _impl_.desc_.Mutable(GetArenaForAllocation());
}
inline std::string* Measure::release_desc() {
    // @@protoc_insertion_point(field_release:proto.Measure.desc)
    return _impl_.desc_.Release();
}
inline void Measure::set_allocated_desc(std::string* desc) {
    if (desc != nullptr) {
    } else {
    }
    _impl_.desc_.SetAllocated(desc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.desc_.IsDefault()) {
        _impl_.desc_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:proto.Measure.desc)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

} // namespace arms_metrics

PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::proto::EnumUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::proto::EnumUnit>() {
    return ::proto::EnumUnit_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MeasureBatches_2eproto
